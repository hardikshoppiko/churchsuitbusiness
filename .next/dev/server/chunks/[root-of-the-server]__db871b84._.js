module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/process [external] (process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("process", () => require("process"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/timers [external] (timers, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("timers", () => require("timers"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[project]/src/lib/db.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "db",
    ()=>db
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mysql2/promise.js [app-route] (ecmascript)");
;
const db = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mysql2$2f$promise$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].createPool({
    host: process.env.DB_HOST,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    port: Number(process.env.DB_PORT || 3306),
    waitForConnections: true,
    connectionLimit: 10
});
}),
"[project]/src/lib/db-utils.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "cn",
    ()=>cn,
    "dbEscape",
    ()=>dbEscape,
    "formatDate",
    ()=>formatDate,
    "generateSalt",
    ()=>generateSalt,
    "getClientIp",
    ()=>getClientIp,
    "getFrontClientIp",
    ()=>getFrontClientIp,
    "isEmail",
    ()=>isEmail,
    "isTenDigitPhone",
    ()=>isTenDigitPhone,
    "isTruthy",
    ()=>isTruthy,
    "money",
    ()=>money,
    "normalizeLogin",
    ()=>normalizeLogin,
    "ocHashPassword",
    ()=>ocHashPassword,
    "ocSerialize",
    ()=>ocSerialize,
    "ocVerifyPassword",
    ()=>ocVerifyPassword,
    "sha1",
    ()=>sha1,
    "stripWebsite",
    ()=>stripWebsite
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/clsx/dist/clsx.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwind$2d$merge$2f$dist$2f$bundle$2d$mjs$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tailwind-merge/dist/bundle-mjs.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$php$2d$serialize$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/php-serialize/lib/esm/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$php$2d$serialize$2f$lib$2f$esm$2f$serialize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__serialize$3e$__ = __turbopack_context__.i("[project]/node_modules/php-serialize/lib/esm/serialize.js [app-route] (ecmascript) <export default as serialize>");
;
;
;
;
function cn(...inputs) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwind$2d$merge$2f$dist$2f$bundle$2d$mjs$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["twMerge"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clsx"])(inputs));
}
function sha1(str) {
    return __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHash("sha1").update(String(str)).digest("hex");
}
function generateSalt() {
    return __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHash("md5").update(__TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].randomBytes(16).toString("hex") + Date.now()).digest("hex").substring(0, 9);
}
function ocHashPassword(password, salt) {
    return sha1(salt + sha1(salt + sha1(password)));
}
function ocVerifyPassword(inputPassword, storedSalt, storedHash) {
    return ocHashPassword(inputPassword, storedSalt) === storedHash;
}
function dbEscape(value) {
    if (value === null || value === undefined) return "";
    return String(value).replace(/\\/g, "\\\\").replace(/\u0008/g, "\\b").replace(/\t/g, "\\t").replace(/\0/g, "\\0").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u001a/g, "\\Z").replace(/\x1a/g, "\\Z").replace(/'/g, "\\'").replace(/"/g, '\\"');
}
function stripWebsite(url = "") {
    return String(url).trim().replace(/^https?:\/\//i, "").replace(/^www\./i, "").replace(/\/+$/, "");
}
function isEmail(v) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/.test(String(v || "").trim());
}
function isTenDigitPhone(v) {
    return /^\d{10}$/.test(String(v || "").trim());
}
function normalizeLogin(v) {
    return String(v || "").trim();
}
function ocSerialize(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$php$2d$serialize$2f$lib$2f$esm$2f$serialize$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__default__as__serialize$3e$__["serialize"])(value);
}
function isTruthy(v) {
    return v === true || v === 1 || v === "1" || String(v).toLowerCase() === "true";
}
function getClientIp(req) {
    if (!req?.headers) return "127.0.0.1";
    // Proxy / Load balancer / Vercel
    const xForwardedFor = req.headers.get("x-forwarded-for");
    if (xForwardedFor) {
        // Can be: "client, proxy1, proxy2"
        return xForwardedFor.split(",")[0].trim();
    }
    // Cloudflare
    const cfIp = req.headers.get("cf-connecting-ip");
    if (cfIp) return cfIp;
    // Fallback (local dev)
    return "127.0.0.1";
}
function getFrontClientIp() {
    const h = headers();
    // Common proxy headers
    const xff = h.get("x-forwarded-for");
    if (xff) return xff.split(",")[0].trim();
    const realIp = h.get("x-real-ip");
    if (realIp) return realIp.trim();
    // Fallback
    return "0.0.0.0";
}
function money(v) {
    const n = Number(v || 0);
    return Number.isFinite(n) ? `$${n.toFixed(2)}` : "$0.00";
}
function parseDate(input) {
    if (!input) return null;
    // Already Date object
    if (input instanceof Date) {
        return isNaN(input.getTime()) ? null : input;
    }
    if (typeof input !== "string") return null;
    // ISO or yyyy-mm-dd hh:mm:ss (MySQL)
    if (/^\d{4}-\d{2}-\d{2}/.test(input)) {
        const d = new Date(input.replace(" ", "T"));
        return isNaN(d.getTime()) ? null : d;
    }
    // dd/mm/yyyy or dd/mm/yyyy hh:mm:ss
    if (/^\d{2}\/\d{2}\/\d{4}/.test(input)) {
        const [datePart, timePart] = input.split(" ");
        const [dd, mm, yyyy] = datePart.split("/");
        const iso = `${yyyy}-${mm}-${dd}${timePart ? "T" + timePart : ""}`;
        const d = new Date(iso);
        return isNaN(d.getTime()) ? null : d;
    }
    // Fallback: let JS try
    const d = new Date(input);
    return isNaN(d.getTime()) ? null : d;
}
function formatDate(input, format = "MM/DD/YYYY") {
    const d = parseDate(input);
    if (!d) return "";
    const map = {
        DD: String(d.getDate()).padStart(2, "0"),
        MM: String(d.getMonth() + 1).padStart(2, "0"),
        YYYY: d.getFullYear(),
        HH: String(d.getHours()).padStart(2, "0"),
        mm: String(d.getMinutes()).padStart(2, "0"),
        ss: String(d.getSeconds()).padStart(2, "0")
    };
    return format.replace(/DD|MM|YYYY|HH|mm|ss/g, (k)=>map[k]);
}
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/child_process [external] (child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("child_process", () => require("child_process"));

module.exports = mod;
}),
"[project]/src/lib/stripe.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "stripe",
    ()=>stripe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stripe/esm/stripe.esm.node.js [app-route] (ecmascript)");
;
const stripe = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stripe$2f$esm$2f$stripe$2e$esm$2e$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](process.env.STRIPE_SECRET_KEY, {
    apiVersion: "2024-06-20"
});
}),
"[project]/src/lib/affiliate-payment-service.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getSubscriptionClientSecret",
    ()=>getSubscriptionClientSecret
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$stripe$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/stripe.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2d$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db-utils.js [app-route] (ecmascript)");
;
;
;
async function getAffiliateById(affiliate_id) {
    const [rows] = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].query(`SELECT * FROM affiliate WHERE affiliate_id='${(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2d$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dbEscape"])(Number(affiliate_id))}' LIMIT 1`);
    return rows?.[0] || null;
}
async function updateAffiliate(affiliate_id, patch) {
    const sets = Object.keys(patch).map((k)=>`\`${k}\`='${(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2d$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dbEscape"])(patch[k])}'`).join(", ");
    await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].query(`UPDATE affiliate SET ${sets}, date_modified=NOW() WHERE affiliate_id='${(0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2d$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["dbEscape"])(Number(affiliate_id))}'`);
}
async function getSubscriptionClientSecret(affiliate_id) {
    const affiliate = await getAffiliateById(affiliate_id);
    if (!affiliate) {
        return {
            affiliate_status: "not_found"
        };
    }
    // If your DB marks already paid
    if (affiliate.payment_status !== undefined && String(affiliate.payment_status || "").toLowerCase() === "paid") {
        return {
            affiliate_status: "paid"
        };
    }
    // 1) Stripe customer
    let stripe_customer_id = affiliate.stripe_customer_id || "";
    if (!stripe_customer_id) {
        const customer = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$stripe$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stripe"].customers.create({
            email: affiliate.email,
            name: `${affiliate.firstname} ${affiliate.lastname}`,
            phone: affiliate.telephone,
            metadata: {
                affiliate_id: String(affiliate.affiliate_id)
            }
        });
        stripe_customer_id = customer.id;
        await updateAffiliate(affiliate.affiliate_id, {
            stripe_customer_id
        });
    }
    // 2) Try reuse stored subscription if exists
    if (affiliate.recurring_billing_id) {
        try {
            const sub = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$stripe$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stripe"].subscriptions.retrieve(affiliate.recurring_billing_id, {
                expand: [
                    "latest_invoice.payment_intent"
                ]
            });
            // If already active -> mark paid
            if (sub.status === "active" || sub.status === "trialing") {
                await updateAffiliate(affiliate.affiliate_id, {
                    payment_status: "paid"
                });
                return {
                    affiliate_status: "paid"
                };
            }
            const pi = sub.latest_invoice?.payment_intent;
            if (pi?.client_secret) {
                return {
                    affiliate_status: "ready",
                    clientSecret: pi.client_secret
                };
            }
        } catch (e) {
        // ignore and create new subscription
        }
    }
    // 3) Create new incomplete subscription
    const priceId = affiliate.stripe_plan_id; // must be Stripe PRICE ID
    if (!priceId) {
        return {
            affiliate_status: "error",
            message: "Stripe plan/price id missing."
        };
    }
    const subscription = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$stripe$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["stripe"].subscriptions.create({
        customer: stripe_customer_id,
        items: [
            {
                price: priceId
            }
        ],
        payment_behavior: "default_incomplete",
        payment_settings: {
            payment_method_types: [
                "card"
            ],
            save_default_payment_method: "on_subscription"
        },
        expand: [
            "latest_invoice.payment_intent"
        ],
        metadata: {
            affiliate_id: String(affiliate.affiliate_id),
            affiliate_plan_id: String(affiliate.affiliate_plan_id || "")
        }
    });
    const pi = subscription.latest_invoice?.payment_intent;
    if (!pi?.client_secret) {
        return {
            affiliate_status: "error",
            message: "Could not create PaymentIntent."
        };
    }
    await updateAffiliate(affiliate.affiliate_id, {
        stripe_customer_id: stripe_customer_id,
        recurring_billing_id: subscription.id,
        stripe_payment_intent_id: pi.id,
        affiliate_status_id: 5
    });
    return {
        affiliate_status: "ready",
        clientSecret: pi.client_secret
    };
}
}),
"[project]/src/app/api/affiliate/payment-intent/route.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET,
    "POST",
    ()=>POST
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2d$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/db-utils.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$affiliate$2d$payment$2d$service$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/src/lib/affiliate-payment-service.js [app-route] (ecmascript)");
;
;
;
async function POST(req) {
    const body = await req.json().catch(()=>({}));
    const affiliate_id = body?.affiliate_id;
    if (!affiliate_id) {
        return Response.json({
            message: "affiliate_id is required"
        }, {
            status: 400
        });
    }
    const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$affiliate$2d$payment$2d$service$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSubscriptionClientSecret"])(affiliate_id);
    if (result.affiliate_status === "not_found") {
        return Response.json({
            message: "Affiliate not found"
        }, {
            status: 404
        });
    }
    if (result.affiliate_status === "paid") {
        return Response.json({
            affiliate_status: "paid"
        });
    }
    if (result.affiliate_status === "error") {
        return Response.json({
            message: result.message || "Payment init failed"
        }, {
            status: 500
        });
    }
    return Response.json({
        affiliate_status: "ready",
        clientSecret: result.clientSecret
    });
}
async function GET(req) {
    try {
        const url = new URL(req.url);
        const affiliate_id = Number(url.searchParams.get("affiliate_id") || 0);
        if (!affiliate_id) {
            return Response.json({
                message: "affiliate_id is required"
            }, {
                status: 400
            });
        }
        // Affiliate info
        const [affRows] = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].query(`SELECT * FROM affiliate WHERE affiliate_id=${affiliate_id}`);
        const affiliate = affRows?.[0] || null;
        if (!affiliate) {
            return Response.json({
                message: "Affiliate not found"
            }, {
                status: 404
            });
        }
        // Latest payment row (for UI)
        const [payRows] = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].query(`SELECT affiliate_payment_id, payment_charge_id, invoice_number, amount, start_date, end_date, payment_status, date_added FROM affiliate_payment WHERE affiliate_id=${affiliate_id} ORDER BY affiliate_payment_id DESC LIMIT 1`);
        const latest_payment = payRows?.[0] || null;
        // Stage helper (first vs renewal)
        const [firstPaidRows] = await __TURBOPACK__imported__module__$5b$project$5d2f$src$2f$lib$2f$db$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].query(`SELECT affiliate_payment_id FROM affiliate_payment WHERE affiliate_id=${affiliate_id} AND payment_status=1 ORDER BY affiliate_payment_id ASC LIMIT 1`);
        const payment_stage = firstPaidRows?.length ? "renewal" : "first";
        return Response.json({
            success: true,
            affiliate,
            latest_payment,
            payment_stage
        });
    } catch (e) {
        return Response.json({
            message: e?.message || "Server error"
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__db871b84._.js.map