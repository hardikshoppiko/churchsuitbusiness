{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///Users/apcrat/Documents/react/church_suit_business/affiliates/src/lib/db.js"],"sourcesContent":["import mysql from \"mysql2/promise\";\n\nexport const db = mysql.createPool({\n  host: process.env.DB_HOST,\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD,\n  database: process.env.DB_NAME,\n  port: Number(process.env.DB_PORT || 3306),\n  waitForConnections: true,\n  connectionLimit: 10,\n});"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,KAAK,8IAAK,CAAC,UAAU,CAAC;IACjC,MAAM,QAAQ,GAAG,CAAC,OAAO;IACzB,MAAM,QAAQ,GAAG,CAAC,OAAO;IACzB,UAAU,QAAQ,GAAG,CAAC,WAAW;IACjC,UAAU,QAAQ,GAAG,CAAC,OAAO;IAC7B,MAAM,OAAO,QAAQ,GAAG,CAAC,OAAO,IAAI;IACpC,oBAAoB;IACpB,iBAAiB;AACnB"}},
    {"offset": {"line": 131, "column": 0}, "map": {"version":3,"sources":["file:///Users/apcrat/Documents/react/church_suit_business/affiliates/src/app/api/automation/cron/route.js"],"sourcesContent":["import { db } from \"@/lib/db\";\n\n/**\n * STEP-5: CRON automation sender (Lead cohort only)\n * - Lead = affiliate_status_id = 15\n * - last_activity = latest affiliate_activity.date_added\n * - Send at 1h, 24h, 72h from last_activity\n * - Insert send_log ONLY after send success\n *\n * Secure with CRON_SECRET header.\n */\n\n// ==========================\n// CONFIG\n// ==========================\n// const CRON_SECRET = process.env.CRON_SECRET || \"\";\nconst APP_URL = process.env.APP_URL || \"http://localhost:3000\";\nconst IS_DEVELOPMENT = ((process.env.IS_DEVELOPMENT === true || process.env.IS_DEVELOPMENT === \"true\") ? 1 : 0);\n\n// ==========================\n// Placeholder replace\n// ==========================\nfunction applyPlaceholders(str = \"\", vars = {}) {\n  let out = String(str || \"\");\n  for (const [k, v] of Object.entries(vars)) {\n    out = out.replaceAll(`{{${k}}}`, String(v ?? \"\"));\n  }\n  return out;\n}\n\n// ==========================\n// SENDERS (Email/SMS stubs)\n// Replace with SendGrid/Twilio later\n// Must return truthy object on success, else false/null\n// ==========================\nasync function sendEmail({ to, subject, html }) {\n  // TODO: integrate SendGrid / SES\n  // Return an object on success\n  console.log(\"EMAIL SEND:\", { to, subject });\n  // Simulate success:\n  return { provider: \"stub\", provider_message_id: `email_${Date.now()}` };\n}\n\nasync function sendSms({ to, text }) {\n  // TODO: integrate Twilio later\n  console.log(\"SMS SEND:\", { to, text });\n  // Simulate \"not enabled\" right now:\n  return null; // <- keep null so it doesn't insert send_log\n}\n\n// ==========================\n// Helpers\n// ==========================\nfunction nowMs() {\n  return Date.now();\n}\n\nfunction msHours(h) {\n  return h * 60 * 60 * 1000;\n}\n\n/**\n * Get last activity time for an affiliate.\n * Uses affiliate_activity table. If no activity rows exist,\n * fallback to affiliate.date_added.\n */\nasync function getLastActivityMap(affiliateIds = []) {\n  if (!affiliateIds.length) return new Map();\n\n  const idsCsv = affiliateIds.map((id) => Number(id)).filter(Boolean).join(\",\");\n  if (!idsCsv) return new Map();\n\n  // latest activity per affiliate\n  const [rows] = await db.query(`SELECT a.affiliate_id, MAX(a.date_added) AS last_activity FROM affiliate_activity a WHERE a.affiliate_id IN (${idsCsv}) GROUP BY a.affiliate_id`);\n\n  const map = new Map();\n\n  for (const r of rows || []) {\n    if (r?.affiliate_id) map.set(Number(r.affiliate_id), r.last_activity);\n  }\n\n  return map;\n}\n\n/**\n * Checks if send_log already exists for (affiliate_id, rule_id, channel)\n */\nasync function alreadySent({ affiliate_id, rule_id, channel }) {\n  const [rows] = await db.query(`\n    SELECT send_log_id\n    FROM affiliate_automation_send_log\n    WHERE affiliate_id='${Number(affiliate_id)}'\n      AND rule_id='${Number(rule_id)}'\n      AND channel='${String(channel)}'\n    LIMIT 1\n  `);\n  return !!rows?.length;\n}\n\n/**\n * Insert send log only after successful send\n */\nasync function insertSendLog({\n  affiliate_id,\n  rule_id,\n  template_code,\n  cohort,\n  channel,\n  dueAtMs,\n  provider_message_id = \"\",\n}) {\n  const dueAtSql = `FROM_UNIXTIME(${Math.floor(dueAtMs / 1000)})`;\n\n  await db.query(`\n    INSERT INTO affiliate_automation_send_log\n      (affiliate_id, rule_id, template_code, cohort, channel,\n       due_at, sent_at, provider_message_id, date_added)\n    VALUES\n      ('${Number(affiliate_id)}',\n       '${Number(rule_id)}',\n       '${String(template_code)}',\n       '${String(cohort)}',\n       '${String(channel)}',\n       ${dueAtSql},\n       NOW(),\n       '${String(provider_message_id || \"\")}',\n       NOW())\n  `);\n}\n\n// ==========================\n// CRON handler\n// ==========================\nexport async function GET(req) {\n  // // ---- simple auth\n  // const secret = req.headers.get(\"x-cron-secret\") || \"\";\n  // if (CRON_SECRET && secret !== CRON_SECRET) {\n  //   return Response.json({ ok: false, message: \"Unauthorized\" }, { status: 401 });\n  // }\n\n  // if(process.env.IS_DEVELOPMENT === true || process.env.IS_DEVELOPMENT === \"true\") {\n  //   console.log(\"CRON run skipped in development mode\");\n  // } else {\n  //   console.log(\"CRON run started\");\n  // }\n\n  console.log(`is Development: ${IS_DEVELOPMENT}`); return false;\n\n  const startedAt = nowMs();\n\n  // 1) Load active rules for Lead cohort only (fixed 3 emails now)\n  const [rules] = await db.query(`SELECT * FROM affiliate_automation_rule WHERE status=1 AND cohort='lead' ORDER BY delay_minutes ASC`);\n\n  if (!rules?.length) {\n    return Response.json({ ok: true, message: \"No rules found\", took_ms: nowMs() - startedAt });\n  }\n\n  // 2) Find eligible lead affiliates (status_id = 15)\n  const [affiliates] = await db.query(`SELECT affiliate_id, firstname, lastname, email, telephone, date_added, affiliate_status_id, stop_automation FROM affiliate WHERE affiliate_status_id=15 AND status=0 AND is_delete=0 AND stop_automation=0 ORDER BY affiliate_id DESC LIMIT 500`);\n\n  if (!affiliates?.length) {\n    return Response.json({ ok: true, message: \"No lead affiliates\", took_ms: nowMs() - startedAt });\n  }\n\n  // console.log(affiliates); return false;\n\n  const affIds = affiliates.map((a) => Number(a.affiliate_id)).filter(Boolean);\n\n  // console.log(affIds); return false;\n\n  // 3) Get last_activity per affiliate from affiliate_activity table\n  const lastActivityMap = await getLastActivityMap(affIds);\n\n  // console.log(`Last activity map loaded for ${lastActivityMap.size} affiliates`); return false;\n\n  // 4) Load templates used by rules (min queries)\n  const templateCodes = Array.from(new Set(rules.map((r) => String(r.template_code || \"\")).filter(Boolean)));\n  let templateByKey = new Map();\n\n  if (templateCodes.length) {\n    const codesSql = templateCodes.map((c) => `'${c.replaceAll(\"'\", \"''\")}'`).join(\",\");\n\n    const [tpls] = await db.query(`SELECT * FROM affiliate_automation_template WHERE status=1 AND code IN (${codesSql})`);\n\n    for (const t of tpls || []) {\n      // key = `${code}:${channel}`\n      templateByKey.set(`${t.code}:${t.channel}`, t);\n    }\n  }\n\n  // 5) Process: for each affiliate, for each rule, check due -> send -> log (only on success)\n  let checked = 0;\n  let sentEmail = 0;\n  let sentSms = 0;\n  let skippedAlreadySent = 0;\n  let skippedNotDue = 0;\n  let skippedNoTemplate = 0;\n  let skippedNoContact = 0;\n  let failedSend = 0;\n\n  const now = nowMs();\n\n  for (const aff of affiliates) {\n    const affiliate_id = Number(aff.affiliate_id);\n    \n    if (!affiliate_id) {\n      continue;\n    }\n\n    const lastActivity = lastActivityMap.get(affiliate_id) || aff.date_added; // fallback\n\n    const lastActivityMs = lastActivity ? new Date(lastActivity).getTime() : 0;\n\n    if (!lastActivityMs) {\n      continue;\n    }\n\n    // variables for templates\n    const payment_url = `${APP_URL}/register/payment/${affiliate_id}`;\n\n    const vars = {\n      affiliate_id,\n      firstname: aff.firstname || \"\",\n      lastname: aff.lastname || \"\",\n      email: aff.email || \"\",\n      telephone: aff.telephone || \"\",\n      payment_url,\n      short_payment_url: payment_url,\n    };\n\n    for (const rule of rules) {\n      checked++;\n\n      const rule_id = Number(rule.rule_id);\n      const channel = String(rule.channel);\n      const template_code = String(rule.template_code);\n      const cohort = String(rule.cohort);\n\n      // compute due\n      const delayMin = Number(rule.delay_minutes || 0);\n      const dueAtMs = lastActivityMs + delayMin * 60 * 1000;\n\n      if (now < dueAtMs) {\n        skippedNotDue++;\n        continue;\n      }\n\n      // skip if already sent\n      const sentBefore = await alreadySent({ affiliate_id, rule_id, channel });\n      if (sentBefore) {\n        skippedAlreadySent++;\n        continue;\n      }\n\n      // find template\n      const tpl = templateByKey.get(`${template_code}:${channel}`);\n      if (!tpl) {\n        skippedNoTemplate++;\n        continue;\n      }\n\n      // contact check\n      if (channel === \"email\" && !String(aff.email || \"\").trim()) {\n        skippedNoContact++;\n        continue;\n      }\n      if (channel === \"sms\" && !String(aff.telephone || \"\").trim()) {\n        skippedNoContact++;\n        continue;\n      }\n\n      // render\n      const subject = applyPlaceholders(tpl.subject || \"\", vars);\n      const body = applyPlaceholders(tpl.body || \"\", vars);\n\n      // send\n      let providerResult = null;\n\n      try {\n        if (channel === \"email\") {\n          providerResult = await sendEmail({\n            to: aff.email,\n            subject,\n            html: body,\n          });\n        } else if (channel === \"sms\") {\n          providerResult = await sendSms({\n            to: aff.telephone,\n            text: body,\n          });\n        }\n      } catch (e) {\n        console.log(\"Send exception:\", e.message);\n        providerResult = null;\n      }\n\n      // IMPORTANT: insert log only if send success\n      if (providerResult) {\n        await insertSendLog({\n          affiliate_id,\n          rule_id,\n          template_code,\n          cohort,\n          channel,\n          dueAtMs,\n          provider_message_id: providerResult?.provider_message_id || \"\",\n        });\n\n        if (channel === \"email\") sentEmail++;\n        if (channel === \"sms\") sentSms++;\n      } else {\n        failedSend++;\n      }\n    }\n  }\n\n  return Response.json({\n    ok: true,\n    cohort: \"lead\",\n    totals: {\n      affiliates: affiliates.length,\n      rules: rules.length,\n      checked,\n      sentEmail,\n      sentSms,\n      skippedAlreadySent,\n      skippedNotDue,\n      skippedNoTemplate,\n      skippedNoContact,\n      failedSend,\n    },\n    took_ms: nowMs() - startedAt,\n  });\n}"],"names":[],"mappings":"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"}}]
}